//!APP-HOOK: pre-build

// This script looks in the "maps" folder and converts Tiled TMX files into Maps.java.
// The TMX files should be orthogonal and in CSV format.

let maps = (dir("maps") || [])
    .filter( file => /\.tmx$/i.test(file) )
    .map( file => readMap(`maps/${file}`) );

for( let map of maps ){
    let usedSets = {};
    let out = [ map.layers.length, map.width, map.height ];

    for( let layer of map.layers ){
        out.push(layer.visible);
        
        for( let id of layer ){
            if( !id ){
                out.push(0, 0);
                continue;
            }

            let tileSet = map.tileSets[id&~0xE0000000];
            usedSets[tileSet.tileSetId] = tileSet;
            out.push((id>>24) + (tileSet.tileSetId<<1) + (((id - tileSet.firstgid + 1)>>8)&0x1));
            out.push((id - tileSet.firstgid + 1)&0xFF);
        }
    }
    
    for( let ts of Object.values(usedSets) ){
        let imagePath = path.resolve(path.join(DATA.projectPath, "maps", ts.source));
        let destPath = path.join(DATA.projectPath, "maps", ts.name + ".png");

        if( imagePath != destPath && !fileExists(destPath)){
            log(`Copying tileset ${ts.name} to maps folder`);
            copyFile(imagePath, destPath);
        }

        write(`maps/${ts.name}.json`, JSON.stringify({
            meta:{
                comment:"Generated by tilemap.js",
                image:ts.name + ".png",
                tile:{
                    w:map.tilewidth,
                    h:map.tileheight
                }
            }
        }));

    }
    
    write(`maps/${map.name}Data.map`, new Uint8Array(out), undefined);
    write(`maps/${map.name}.java`, `package maps;
// Do not edit.
// This file is generated by tilemap.js on build-time.

import femto.TileSet;
import femto.mode.HiRes16Color;
import static System.memory.*;

public class ${map.name} extends BaseMap {
    public ${map.name}(){
        super(${map.name}Data.map(), new TileSet[]{
            ${Object.values(usedSets).sort((a, b)=>(a.firstgid|0) - (b.firstgid|0)).map(s=>`new ${s.name}()`).join(",\n\t\t\t")}
        });
    }
    ${map.layers.map((layer, num)=>`
    void draw${layer.name.replace(/[^a-zA-Z0-9_]/g, '')}(HiRes16Color screen){
        draw(screen, ${num});
    }
    int read${layer.name.replace(/[^a-zA-Z0-9_]/g, '')}(int tileX, int tileY){
        pointer addr = this.data + ${4+num*(1+map.width*2*map.height)} + tileY*${map.width*2} + tileX*2;
        return (((int)LDRB(addr)&1)<<8) + LDRB(addr+1);
    }
`).join('')}
}
    `);
}

// Tell the build system we're done
if(hookTrigger == "pre-build")
    hookArgs[1]();
    
function readMap(filePath){
    let xml = XML(read(filePath));
    let layers = getLayers(xml);
    let tileSets = [];
    let name = path.basename(filePath).replace(/\..*/, "");
    let map = { name, layers, tileSets };
    
    for( let attr of [...xml.querySelector("map").attributes] )
        map[attr.name] = /^[0-9]+$/.test(attr.value) ? attr.value|0 : attr.value;

    getTileSets(xml).map((ts, tileSetId)=>{
        ts.tileSetId = tileSetId;
        ts.gid = ts.firstgid|0;
        for( let i=0; i<ts.tilecount|0; ++i )
            tileSets[ts.gid+i] = ts;
    });

    return map;
}

function getLayers(xml){
    return [...xml.querySelectorAll("layer")]
        .map(layer=>{
            let data = layer.textContent.split(/\s*,\s*/).map(x=>x|0);
            [...layer.attributes]
                .reduce((obj, attr)=>(obj[attr.name] = attr.value, obj), data);
            Object.assign(data, getProperties(layer));
            data.visible = data.visible != "0" && data.visible != "false";
            return data;
        });
}

/*
 <tileset firstgid="1" name="magecity_1" tilewidth="16" tileheight="16" tilecount="360" columns="8">
  <image source="../../../../../../../Pictures/tileset/16x16/magecity_1.png" width="128" height="725"/>
 </tileset>
*/
function getTileSets(xml){
    return [...xml.querySelectorAll("tileset")]
        .map(tset=>Object.assign(
            {}, 

            [...tset.attributes]
                .reduce((obj, attr)=>(obj[attr.name] = attr.value, obj), {}),

            [...(tset.querySelector("image")||{attributes:[]}).attributes]
                .reduce((obj, attr)=>(obj[attr.name] = attr.value, obj), {}),
            
            [...(tset.querySelectorAll("tile"))]
                .reduce((obj, tile)=>{
                    obj.properties[tile.id|0] = getProperties(tile);
                    return obj;
                }, {properties:{}})
        ))
        .sort((a, b)=>(a.firstgid|0) - (b.firstgid|0));
}

function getProperties(node){
    return [...node.querySelectorAll("property")].reduce((o, prop)=>{
                        o[prop.attributes.name.value.trim()] = prop.attributes.value.value.trim();
                        return o;
                    }, {});
}
